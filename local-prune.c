// TO DO: discard errorHandle function, rewrite necessary code

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <stdbool.h>


/*
Author: ThamesDev <https://github.com/ThamesDev>
Description: A C program designed to solve the portability issues created by the initial shell script (compilation
to binary was done via the shc compiler, but this generated some dependency issues, as well as build errors on the
launchpad repo). Additionally, the C program generated by shc proved not to be portable across systems without, or
even with, the shc compiler installed. The reason for this is unknown, but the file was inefficient and mostly un-
readable - it really looked like the product of a computer, not a human. This is hopefully more human-readable, as
well as better documented, than the shc C program. It is also smaller (74 lines without comments vs 772, checkmate
compiler). Yes, this is just a bash script rewritten in C for portability.
Date created: 2021/06/30

Error code guide:
   -1: Command processor not found
	0: Program executed successfully
	1: Too many/too few arguments
	2: Could not access working directory
	3: Command not executed within a git repo
	4: Invalid primary branch argument given
	5: Upstream primary branch not specified
	6: No available tracking branches to prune
*/


int errorHandle(int input, int code, int _return) // For the sake of conciseness and readability, this function was added
{
	if (input==code) // Checks whether the exit code of a program matches a value, and exits with the corresponding return
	{
		/* No printf() statement is needed here as the program handles it. It would have proven more difficult
		to supress errors and add my own. */
		return _return; //There is no way to get this to directly return for the main() function
	} else //This else isn't strictly necessary, but it makes the code more immediately understandable
	{
		return 0;
	}
} // I know this doesn't look like much, but it saves a lot of space and mitigates typos. You'll just have to trust me ;)


int main(int argc, char *argv[]) // Takes one extra input in the form of a char array 
{	
	char line2[20]; // The first line of the script
	char cwd[PATH_MAX]; // Defines the working directory
	int error; // Stores the value of the errorHandle() function to return an error if necessary

	error = errorHandle(system(NULL), 0, -1); // Checks that the command processor can be reached, if not exits
	if ((bool) error) // This code ends up being repeated quite a lot, but since it returns the main() function, I couldn't put it inside another one
	{
		return error;
	}
	// Checks that the number of arguments for the function is correct
	switch (argc)
	{
	case 1:
		printf("fatal error: expected primary branch argument.\n");
		return 1;
	case 2: // The filename of the program itself is considered an argument, so 2 arguments is correct
		break;
	default:
		printf("fatal error: too many arguments given!\n"); // Having no arguments is impossible (see above), so this only deals with excess arguments
		return 1; // In this case both exits pertain to arguments, so I have assigned the same exit code
	}

	// Checks that the working directory can be fetched, mostly just for redundancy
	// (also I wasted too much time on this useless feature to leave it out)
	if (getcwd(cwd, sizeof(cwd)) != NULL) // Checks that the working drectory has a non-zero length
	{
		printf("Working directory (%s) found.\n", cwd);
	} else
	{
		printf("fatal error: working directory unavailable!"); // This used to use perror(), but the formatting of errors was inconsistent across programs
		return 2;
	}

	// Checks that the user is in a git repo, if not exits
	error = errorHandle(system("git status"), 32768, 3);
	if ((bool) error)
	{
		printf("local-prune: this means that you ran this command outside a git repo.\n");
		return error;
	}

	strcpy(line2, "git checkout ");
	strcat(line2, argv[1]);

	// Checks that the provided primary branch is valid, if not exits
	error = errorHandle(system(line2), 256, 4);
	if ((bool) error)
	{
		printf("local-prune: this means that you have entered an invalid argument for the main branch.\n");
		return error;
	}

	// It is difficult to produce an error with this command, for whatever reason, so for the sake of time no error handling is used
	system("git fetch -p");

	// Checks that the primary branch has remote tracking information associated
	error = errorHandle(system("git pull"), 256, 5);
	if ((bool) error)
	{
		printf("local-prune: This means that you have not set the upstream source for you primary branch.\n");
		return error;
	}

	// Checks if there are orphaned remote tracking branches, and if so prunes them
	error = errorHandle(system("git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -d"), 31488, 6);
	if ((bool) error)
	{
		printf("local-prune: this means that there are no remote tracking branches to prune.\n");
		return error;
	}

	return 0; // If the program gets through all of this mess, success!
}